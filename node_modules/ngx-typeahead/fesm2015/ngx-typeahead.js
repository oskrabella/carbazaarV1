import { __decorate } from 'tslib';
import { HttpParams, HttpClient, HttpClientModule, HttpClientJsonpModule } from '@angular/common/http';
import { EventEmitter, ElementRef, ViewContainerRef, ChangeDetectorRef, Input, Output, ViewChild, TemplateRef, HostListener, Component, NgModule } from '@angular/core';
import { Subject, of } from 'rxjs';
import { filter, map, debounceTime, concat, distinctUntilChanged, tap, switchMap } from 'rxjs/operators';
import { CommonModule } from '@angular/common';

var Key;
(function (Key) {
    Key["Backspace"] = "Backspace";
    Key["Tab"] = "Tab";
    Key["Enter"] = "Enter";
    Key["ShiftLeft"] = "ShiftLeft";
    Key["ShiftRight"] = "ShiftRight";
    Key["Escape"] = "Escape";
    Key["ArrowLeft"] = "ArrowLeft";
    Key["ArrowRight"] = "ArrowRight";
    Key["ArrowUp"] = "ArrowUp";
    Key["ArrowDown"] = "ArrowDown";
    // http://unixpapa.com/js/key.html
    Key["MetaLeft"] = "MetaLeft";
    Key["MetaRight"] = "MetaRight";
})(Key || (Key = {}));

function validateNonCharKeyCode(keyCode) {
    return [
        Key.Enter,
        Key.Tab,
        Key.ShiftLeft,
        Key.ShiftRight,
        Key.ArrowLeft,
        Key.ArrowUp,
        Key.ArrowRight,
        Key.ArrowDown,
        Key.MetaLeft,
        Key.MetaRight,
    ].every((codeKey) => codeKey !== keyCode);
}
function validateArrowKeys(keyCode) {
    return keyCode === Key.ArrowDown || keyCode === Key.ArrowUp;
}
function isIndexActive(index, currentIndex) {
    return index === currentIndex;
}
function isEnterKey(event) {
    return event.code === Key.Enter;
}
function isEscapeKey(event) {
    // tslint:disable-next-line: deprecation
    return event.code === Key.Escape;
}
function createParamsForQuery(query, queryParamKey = 'q', customParams = {}) {
    const searchParams = Object.assign({ [queryParamKey]: query }, customParams);
    // tslint:disable-next-line
    const setParam = (acc, param) => acc.set(param, searchParams[param]);
    const params = Object.keys(searchParams).reduce(setParam, new HttpParams());
    return params;
}
function resolveApiMethod(method = '') {
    const isMethodValid = [
        'get',
        'post',
        'put',
        'delete',
        'patch',
        'request',
    ].some((methodName) => method === methodName);
    const apiMethod = isMethodValid ? method : 'get';
    return apiMethod;
}
const NO_INDEX = -1;
function resolveNextIndex(currentIndex, stepUp, listLength = 10) {
    const step = stepUp ? 1 : -1;
    const topLimit = listLength - 1;
    const bottomLimit = NO_INDEX;
    const currentResultIndex = currentIndex + step;
    let resultIndex = currentResultIndex;
    if (currentResultIndex === topLimit + 1) {
        resultIndex = bottomLimit;
    }
    if (currentResultIndex === bottomLimit - 1) {
        resultIndex = topLimit;
    }
    return resultIndex;
}
function toJsonpSingleResult(response) {
    return response[1];
}
function toJsonpFinalResults(results) {
    return results.map((result) => result[0]);
}
function hasCharacters(query) {
    return query.length > 0;
}
function toFormControlValue(e) {
    return e.target.value;
}
function resolveItemValue(item, fieldsToExtract, caseSensitive = false) {
    let newItem = item;
    if (!item.hasOwnProperty('length')) {
        const fields = !fieldsToExtract.length
            ? Object.keys(item)
            : fieldsToExtract;
        newItem = fields.reduce((acc, cur) => `${acc}${item[cur]}`, '');
    }
    return caseSensitive ? newItem : newItem.toLowerCase();
}

/*
 using an external template:
 <input [taItemTpl]="itemTpl" >

  <ng-template #itemTpl let-result>
    <strong>MY {{ result.result }}</strong>
  </ng-template>
*/
let NgxTypeAheadComponent = class NgxTypeAheadComponent {
    constructor(element, viewContainer, http, cdr) {
        this.element = element;
        this.viewContainer = viewContainer;
        this.http = http;
        this.cdr = cdr;
        this.showSuggestions = false;
        this.results = [];
        this.taUrl = '';
        this.taParams = {};
        this.taQueryParam = 'q';
        this.taApi = 'jsonp';
        this.taApiMethod = 'get';
        this.taList = [];
        this.taListItemField = [];
        this.taListItemLabel = '';
        this.taDebounce = 300;
        this.taAllowEmpty = false;
        this.taCaseSensitive = false;
        this.taDisplayOnFocus = false;
        this.taSelected = new EventEmitter();
        this.suggestionIndex = 0;
        this.subscriptions = [];
        this.activeResult = '';
        this.searchQuery = '';
        this.selectedItem = {};
        this.resultsAsItems = [];
        this.keydown$ = new Subject();
        this.keyup$ = new Subject();
    }
    handleEsc(event) {
        if (isEscapeKey(event)) {
            this.hideSuggestions();
            event.preventDefault();
        }
        this.keydown$.next(event);
    }
    onkeyup(event) {
        event.preventDefault();
        event.stopPropagation();
        this.keyup$.next(event);
    }
    onClick() {
        if (this.taDisplayOnFocus) {
            this.displaySuggestions();
        }
    }
    ngOnInit() {
        this.filterEnterEvent(this.keydown$);
        this.listenAndSuggest(this.keyup$);
        this.navigateWithArrows(this.keydown$);
        this.renderTemplate();
    }
    ngOnDestroy() {
        this.keydown$.complete();
        this.keyup$.complete();
    }
    renderTemplate() {
        if (!this.suggestionsTplRef) {
            console.error('NO NGXTA Template Found. Requires NG9');
            return;
        }
        this.viewContainer.createEmbeddedView(this.suggestionsTplRef);
        this.cdr.markForCheck();
    }
    listenAndSuggest(obs) {
        obs
            .pipe(
        // tslint:disable-next-line: deprecation
        filter((e) => validateNonCharKeyCode(e.code)), map(toFormControlValue), debounceTime(this.taDebounce), 
        // tslint:disable-next-line: deprecation
        concat(), distinctUntilChanged(), filter((query) => this.taAllowEmpty || hasCharacters(query)), tap((query) => (this.searchQuery = query)), switchMap((query) => this.suggest(query)))
            .subscribe((results) => {
            this.assignResults(results);
            // this.updateIndex(Key.ArrowDown);
            this.displaySuggestions();
        });
    }
    assignResults(results) {
        const labelForDisplay = this.taListItemLabel;
        this.resultsAsItems = results;
        this.results = results.map((item) => labelForDisplay ? item[labelForDisplay] : item);
        this.suggestionIndex = NO_INDEX;
        if (!results || !results.length) {
            this.activeResult = this.searchQuery;
        }
    }
    filterEnterEvent(elementObs) {
        elementObs.pipe(filter(isEnterKey)).subscribe((event) => {
            this.handleSelectSuggestion(this.activeResult);
        });
    }
    navigateWithArrows(elementObs) {
        elementObs
            .pipe(map((e) => e.key), filter((key) => validateArrowKeys(key)))
            .subscribe((key) => {
            this.updateIndex(key);
            this.displaySuggestions();
        });
    }
    updateIndex(keyCode) {
        this.suggestionIndex = resolveNextIndex(this.suggestionIndex, keyCode === Key.ArrowDown, this.results.length);
    }
    displaySuggestions() {
        this.showSuggestions = true;
        this.cdr.markForCheck();
    }
    suggest(query) {
        return this.taList.length
            ? this.createListSource(this.taList, query)
            : this.request(query);
    }
    /**
     * peforms a jsonp/http request to search with query and params
     * @param query the query to search from the remote source
     */
    request(query) {
        const url = this.taUrl;
        const searchConfig = createParamsForQuery(query, this.taQueryParam, this.taParams);
        const options = {
            params: searchConfig,
        };
        const isJsonpApi = this.taApi === 'jsonp';
        return isJsonpApi
            ? this.requestJsonp(url, options, this.taCallbackParamValue)
            : this.requestHttp(url, options);
    }
    requestHttp(url, options) {
        const apiMethod = resolveApiMethod(this.taApiMethod);
        return this.http[apiMethod](url, options);
    }
    requestJsonp(url, options, callback = 'callback') {
        const params = options.params.toString();
        return this.http
            .jsonp(`${url}?${params}`, callback)
            .pipe(map(toJsonpSingleResult), map(toJsonpFinalResults));
    }
    markIsActive(index, result) {
        const isActive = isIndexActive(index, this.suggestionIndex);
        if (isActive) {
            this.activeResult = result;
        }
        return isActive;
    }
    handleSelectionClick(suggestion, index) {
        this.suggestionIndex = index;
        this.handleSelectSuggestion(suggestion);
    }
    handleSelectSuggestion(suggestion) {
        const result = this.resultsAsItems.length
            ? this.resultsAsItems[this.suggestionIndex]
            : suggestion;
        this.hideSuggestions();
        const resolvedResult = this.suggestionIndex === NO_INDEX ? this.searchQuery : result;
        this.taSelected.emit(resolvedResult);
    }
    hideSuggestions() {
        this.showSuggestions = false;
    }
    hasItemTemplate() {
        return this.taItemTpl !== undefined;
    }
    createListSource(list, query) {
        const sanitizedQuery = this.taCaseSensitive ? query : query.toLowerCase();
        const fieldsToExtract = this.taListItemField;
        return of(list.filter((item) => {
            return resolveItemValue(item, fieldsToExtract, this.taCaseSensitive).includes(sanitizedQuery);
        }));
    }
};
NgxTypeAheadComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ViewContainerRef },
    { type: HttpClient },
    { type: ChangeDetectorRef }
];
__decorate([
    Input()
], NgxTypeAheadComponent.prototype, "taItemTpl", void 0);
__decorate([
    Input()
], NgxTypeAheadComponent.prototype, "taUrl", void 0);
__decorate([
    Input()
], NgxTypeAheadComponent.prototype, "taParams", void 0);
__decorate([
    Input()
], NgxTypeAheadComponent.prototype, "taQueryParam", void 0);
__decorate([
    Input()
], NgxTypeAheadComponent.prototype, "taCallbackParamValue", void 0);
__decorate([
    Input()
], NgxTypeAheadComponent.prototype, "taApi", void 0);
__decorate([
    Input()
], NgxTypeAheadComponent.prototype, "taApiMethod", void 0);
__decorate([
    Input()
], NgxTypeAheadComponent.prototype, "taList", void 0);
__decorate([
    Input()
], NgxTypeAheadComponent.prototype, "taListItemField", void 0);
__decorate([
    Input()
], NgxTypeAheadComponent.prototype, "taListItemLabel", void 0);
__decorate([
    Input()
], NgxTypeAheadComponent.prototype, "taDebounce", void 0);
__decorate([
    Input()
], NgxTypeAheadComponent.prototype, "taAllowEmpty", void 0);
__decorate([
    Input()
], NgxTypeAheadComponent.prototype, "taCaseSensitive", void 0);
__decorate([
    Input()
], NgxTypeAheadComponent.prototype, "taDisplayOnFocus", void 0);
__decorate([
    Output()
], NgxTypeAheadComponent.prototype, "taSelected", void 0);
__decorate([
    ViewChild(TemplateRef, { static: true })
], NgxTypeAheadComponent.prototype, "suggestionsTplRef", void 0);
__decorate([
    HostListener('keydown', ['$event'])
], NgxTypeAheadComponent.prototype, "handleEsc", null);
__decorate([
    HostListener('keyup', ['$event'])
], NgxTypeAheadComponent.prototype, "onkeyup", null);
__decorate([
    HostListener('click')
], NgxTypeAheadComponent.prototype, "onClick", null);
NgxTypeAheadComponent = __decorate([
    Component({
        // tslint:disable-next-line: component-selector
        selector: 'ngx-typeahead, [ngxTypeahead]',
        template: `
    <ng-template #suggestionsTplRef>
      <section class="ta-results list-group" *ngIf="showSuggestions">
        <div class="ta-backdrop" (click)="hideSuggestions()"></div>
        <button
          type="button"
          class="ta-item list-group-item"
          *ngFor="let result of results; let i = index"
          [class.active]="markIsActive(i, result)"
          (click)="handleSelectionClick(result, i)"
        >
          <span *ngIf="!taItemTpl"
            ><i class="fa fa-search"></i> {{ result }}</span
          >
          <ng-template
            [ngTemplateOutlet]="taItemTpl"
            [ngTemplateOutletContext]="{
              $implicit: { result: result, index: i }
            }"
          ></ng-template>
        </button>
      </section>
    </ng-template>
  `,
        styles: [`
      .ta-results {
        position: absolute;
      }
      .ta-backdrop {
        bottom: 0;
        left: 0;
        position: fixed;
        right: 0;
        top: 0;
        z-index: 1;
      }
      .ta-item {
        position: relative;
        z-index: 2;
        display: block;
      }
    `]
    })
], NgxTypeAheadComponent);

let NgxTypeaheadModule = class NgxTypeaheadModule {
};
NgxTypeaheadModule = __decorate([
    NgModule({
        declarations: [NgxTypeAheadComponent],
        imports: [CommonModule, HttpClientModule, HttpClientJsonpModule],
        exports: [NgxTypeAheadComponent, CommonModule]
    })
], NgxTypeaheadModule);

/*
 * Public API Surface of ngx-typeahead
 */

/**
 * Generated bundle index. Do not edit.
 */

export { NgxTypeAheadComponent, NgxTypeaheadModule };
//# sourceMappingURL=ngx-typeahead.js.map
